TestNG - Фреймворк, имеющий некоторые преимущества на фоне JUnit и NUnit, например тем, что более гибкий и расширяемый. Сделан «по мотивам» JUnit с учетом его слабых мест. Открытый исходный код.


https://javarush.com/groups/posts/2500-vse-o-unit-testing-metodiki-ponjatija-praktika

тест - проверка правильности работы нашей системы в тех или иных ситуациях.

JUnit, TestNG - фреймворки тестирования

1) Модульное тестирование (unit testing) — тесты, задача которых проверить каждый модуль системы по отдельности. Желательно, чтобы это были минимально делимые кусочки системы, например, модули.
2) Системное тестирование (system testing) — тест высокого уровня для проверки работы большего куска приложения или системы в целом.
3) Регрессионное тестирование (regression testing) — тестирование, которое используется для проверки того, не влияют ли новые фичи или исправленные баги на существующий функционал приложения 
    и не появляются ли старые баги.
4) Функциональное тестирование (functional testing) — проверка соответствия части приложения требованиям, заявленным в спецификациях, юзерсторях и т. д.

Виды функционального тестирования:
 * тест «белого ящика» (white box) на соответствие части приложения требованиям со знанием внутренней реализации системы;
 * тест «черного ящика» (black box) на соответствие части приложения требованиям без знания внутренней реализации системы.

5) Тестирование производительности (performance testing) — вид тестов, которые пишутся для определения скорости отработки системы или ее части под определённой нагрузкой.
6) Нагрузочное тестирование (load testing) — тесты, предназначенные для проверки устойчивости системы при стандартных нагрузках и для нахождения максимально возможного пика, 
     при котором приложение работает корректно.
7) Стресс-тестирование (stress testing) — вид тестирования, предназначенный для проверки работоспособности приложения при нестандартных нагрузках и для определения максимально возможного пика, 
     при котором система не упадёт.
8) Тестирование безопасности (security testing) — тесты, используемые для проверки безопасности системы 
    (от атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным и прочих радостей жизни).
9) Тестирование локализации (localization testing) — это тесты локализации для приложения.
10) Юзабилити тестирование (usability testing) — вид тестирования, направленный на проверку удобства использования, понятности, привлекательности и обучаемости для пользователей.

Мок (Mock) — объекты, которые настраиваются (например, специфично для каждого теста) и позволяют задать ожидания вызовы методов в виде ответов, которые мы планируем получить. 
Проверки соответствия ожиданиям проводятся через вызовы к Mock-объектам.

Заглушки (Stub) — обеспечивают жестко зашитый ответ на вызовы во время тестирования. 
Также они могут сохранять в себе информацию о вызове (например, параметры или количество этих вызовов). Такие иногда называют своим термином — шпион (Spy).

Иногда эти термины stubs и mock путают: разница в том, что стаб ничего не проверяет, а лишь имитирует заданное состояние. 
А мок — это объект, у которого есть ожидания. Например, что данный метод класса должен быть вызван определенное число раз. 
Иными словами, ваш тест никогда не сломается из-за «стаба», а вот из-за мока может.

---------
JUnit 

JUnit тест представляет собой метод, содержащийся в классе, который используется только для тестирования. Класс, как правило, называется так же, как и класс, который он тестирует с +Test в конце. 
Например, CarService→ CarServiceTest. Система сборки Maven автоматически включает такие классы в тестовую область. По сути этот класс и называется тестовым.

@Test — определение данного метода в качестве тестируемого (по сути — метод, помеченный данной аннотацией и есть модульный тест).
@Before — помечается метод, который будет выполняться перед каждым тестом. Например, заполнение тестовых данных класса, чтение входных данных и т. д.
@After — ставится над методом, который будет вызывать после каждого теста (чистка данных, восстановление дефолтных значений).
@BeforeClass — ставится над методом — аналог @Before. Но этот метод вызывается лишь однажды перед всеми тестами для данного класса и поэтому должен быть статическим. 
                 Он используется для выполнения более тяжелых операций, как например подъем тестовой БД.
@AfterClass — противоположность @BeforeClass: исполняется один раз для данного класса, но исполняется после всех тестов. Используется, например, для очистки постоянных ресурсов или отключения от БД.
@Ignore — отмечает, что метод ниже отключен и будет игнорироваться при общей прогонке тестов. Используется в разных случаях, например, если изменили базовый метод и не успели переделать под него тест.
                 В таких случаях ещё желательно добавить описание — @Ignore("Some description").
@Test (expected = Exception.class) — используется для отрицательных тестов. Это тесты, которые проверяют, как ведёт себя метод в случае ошибки, то есть тест ожидает, 
                 что метод выкинет некоторое исключение. Такой метод обозначается аннотацией @Test, но с указанием ошибки для отлова.
@Test(timeout=100) — проверяет, что метод исполняется не более чем 100 миллисекунд.
@Mock — используется над полем класс для задания данного объекта моком (не из Junit библиотеки, а из Mockito). 
                 При необходимости можем задать поведение мока в конкретной ситуации, непосредственно в методе теста.

@RunWith(MockitoJUnitRunner.class) — метод ставится над классом. Он и является кнопкой для прогона тестов в нем. 
   Runner-ы могут быть различными: например, есть такие: MockitoJUnitRunner, JUnitPlatform, SpringRunner и т. д.). 
   В JUnit 5 аннотацию @RunWith заменили более мощной аннотацией @ExtendWith.


Некоторые методы сравнения результатов:
assertEquals(Object expecteds, Object actuals) — проверяет, равны ли передаваемые обьекты.
assertTrue(boolean flag) — проверяет, возвращает ли переданное значение — true.
assertFalse(boolean flag) — проверяет, возвращает ли переданное значение — false.
assertNull(Object object) – проверяет, является ли объект нулевым (null).
assertSame(Object firstObject, Object secondObject) — проверяет, ссылаются ли передаваемые значения на один и тот же обьект.
assertThat(T t, Matcher<T> matcher) — проверяет, удовлетворяет ли t условию, указанному в matcher.

Подключаем тестирование в буте:
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-test</artifactId>
   <version>2.2.2.RELEASE</version>
   <scope>test</scope>
</dependency>


Вроде, работает:
<dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-inline</artifactId>
            <version>5.2.0</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-junit-jupiter</artifactId>
            <version>5.2.0</version>
            <scope>compile</scope>
        </dependency>
</dependencies>



--------------------

https://www.freecodecamp.org/news/java-unit-testing/







-------------------


jUnit5
https://habr.com/ru/articles/590741/





------------------

https://blog.skillfactory.ru/glossary/mockito/

Mockito — фреймворк для тестирования приложений, который позволяет легко и быстро подменять реальные объекты программы «пустышками». 
Такие фиктивные объекты часто называют «моками» (Mock — подражать).

Mockito упрощает разработку юнит-тестов для классов с внешними зависимостями. Фиктивная реализация интерфейса, статического метода или класса, которую производит Mockito, позволяет определить вывод конкретных вызовов методов: фиктивные классы записывают взаимодействие с системой, а тесты могут его проверить и подтвердить.

<dependency>
 <groupId>org.mockito</groupId>
 <artifactId>mockito-core</artifactId>
 <version>4.3.1</version>
 <scope>test</scope>
</dependency>

В случае совместного использования JUnit 5 и Mockito в Maven также добавляется следующая зависимость:
<dependency>
 <groupId>org.junit.jupiter</groupId>
 <artifactId>junit-jupiter-engine</artifactId>
 <version>5.5.2</version>
 <scope>test</scope>
</dependency>

Традиционный подход к тестированию — создание «заглушек», конкретных реализаций интерфейса, подходящих для данного сценария. 
Такие реализации имеют жестко закодированную логику. Заглушка — разновидность тестового двойника (как и фиктивные объекты, макеты, шпионы и так далее). 
В Mockito чаще всего используются два типа тестовых двойников — макеты (mocks) и шпионы (spies).

---

Макеты (моки)
Такое тестирование называют мокингом. Создаются объекты-имитаторы, которые реализуют поведение реальной подсистемы. Моки используются как замена зависимостей.

С помощью Mockito разработчик создает имитатор — мок, указывает библиотеке, что делать при вызове определенных методов, а затем использует экземпляр имитатора в своем тесте 
вместо реального объекта. По умолчанию Mockito предоставляет реализацию для каждого метода mock. После тестирования можно запросить mock, чтобы узнать, 
какие конкретные методы были вызваны, или проверить побочные эффекты в виде изменения состояния.

---

Шпионы

Шпион — второй тестовый двойник, который создает Mockito. Для этого требуется экземпляр объекта, за которым можно наблюдать — шпионить. 
По умолчанию шпион делегирует все вызовы методов реальному объекту и записывает, какой метод был вызван и какие имел параметры.

Шпионы полезны для тестирования устаревшего кода. Но если приходится использовать шпион для частичного моделирования класса, значит, класс выполняет слишком много действий. 
Это идет вразрез с принципом единой ответственности.

---

Создание моков с помощью Mockito API

Библиотека Mockito позволяет создавать mock-объекты разными методами:
* с применением расширения @ExtendWith(MockitoExtension.class) для JUnit 5 в сочетании с аннотацией @Mock;
* c помощью статического метода mock();
* c использованием аннотации @Mock.

При использовании аннотации @Mock нужно подготовить к работе аннотированные поля. Расширение MockitoExtension делает это, вызывая статический метод MockitoAnnotations.initMocks().

Моки могут возвращать различные значения в зависимости от аргументов, переданных в метод. Цепочка методов when(…).thenReturn(…) используется для указания возвращаемого значения 
для вызова метода с заранее заданными параметрами. Для возврата значений также можно использовать такие методы, как anyString или anyInt.

---

После того как библиотека mockito-inline пришла на смену mockito-core, у пользователей появилась возможность создавать моки финальных классов и статических методов.
Mockito делает код тестов проще и понятнее благодаря использованию фиктивных интерфейсов, прослушивающих вызовов, сопоставителей и захватчиков аргументов.



--------
https://habr.com/ru/articles/444982/

Mockito — фреймворк для работы с заглушками.

При тестировании кода (прежде всего юнит-тестировании, но не только) тестируемому элементу часто требуется предоставить экземпляры классов, которыми он должен пользоваться при работе. 
При этом часто они не должны быть полнофункциональными — наоборот, от них требуется вести себя жёстко заданным образом, так, чтобы их поведение было простым и полностью предсказуемым. Они и называются заглушками (stub). Чтобы их получить, можно создавать альтернативные тестовые реализации интерфейсов, наследовать нужные классы с переопределением функционала и так далее, но всё это достаточно неудобно, избыточно и чревато ошибками. Более удобное во всех смыслах решение — специализированные фреймворки для создания заглушек. 
Одним из таковых (и, пожалуй, самым известным для Java) и является Mockito.

Mockito позволяет создать одной строчкой кода так называемый mock (что-то вроде основы для нужной заглушки) любого класса. Для такого mock сразу после создания характерно некое поведение по умолчанию (все методы возвращают заранее известные значения — обычно это null либо 0). Можно переопределить это поведение желаемым образом, проконтролировать с нужной степенью детальности обращения к ним так далее. В результате mock и становится заглушкой с требуемыми свойствами.

mock можно создать и для тех классов, новый экземпляр которых вообще-то так просто не создашь, в частности, классов с исключительно приватными конструкторами типа синглтонов и утилитных классов, а при минимальной настройке фреймворка — и перечислений (enums).

Центральный класс Mockito, через который предполагается обращаться к большей части функционала, — это, собственно, класс под названием Mockito (есть также класс BDDMockito, предоставляющий примерно те же возможности в форме, более подходящей для BDD, но здесь я не стану на нём останавливаться). Доступ к функционалу реализован через его статические методы.

Создаем mock класса DataService:
DataService dataServiceMock = Mockito.mock(DataService.class);

Получили экземпляр нужного класса. Он будет принят любым методом или конструктором, которому требуется параметр такого типа.

не только instanceof DataService вернёт true, но и dataServiceMock.getClass() — именно DataService.class

Каким-то формальным образом программно отличить mock-объект от обычного оказывается довольно непростой задачей, что и логично: ведь первый предназначен как раз для того, чтобы быть неотличимым от второго. Однако в составе Mockito для этого есть инструмент — метод Mockito.mockingDetails. Передав ему произвольный объект, получим объект класса MockingDetails. Он содержит информацию о том, что этот объект представляет собой с точки зрения Mockito: является ли он mock, spy, как использовался, как был создан и прочее.


Особо нужно упомянуть ситуацию создая mock для final класса или mock-экземпляра enum либо переопределение поведение final метода. 
В таком случае при поведении Mockito по умолчанию код выше откажется работать, сославшись именно на это обстоятельство. 
Однако это можно изменить — достаточно создать в проекте (при стандартном устройстве проектного дерева каталогов) 
файл test/resources/mockito-extensions/org.mockito.plugins.MockMaker и вписать в него строчку:
mock-maker-inline

После этого можно имитировать обычным способом final классы и enum'ы, а также переопределять final методы.

Полученный mock в действии максимально безлик: ни один метод при вызове не окажет никакого воздействия на что бы то ни было, 
а возвращённое значение окажется null для объектных типов и 0 для примитивных. 
Обратите внимание: если метод возвращает коллекцию, mock'ом по умолчанию будут возвращены не null'ы, а пустые экземпляры коллекций.
В качестве значений массивов, примитивных или объектных, получим null

Поведение по умолчанию (и не только его) можно изменить при помощи функционала класса MockSettings


Допустим, нужно использовать в качестве заглушки объект реального класса с имеющимся функционалом, переопределив работу только части его методов.
На этот случай в Mockito есть так называемые spy.
В отличие от mock'ов, их можно создавать на основе как класса, так и готового объекта

DataService dataServiceSpy = Mockito.spy(DataService.class);
// or
DataService dataService = new DataService();
dataServiceSpy = Mockito.spy(dataService);

При создании spy на основе класса, если его тип — интерфейс, будет создан обычный mock-объект, а если тип — класс, то Mockito попытается создать экземпляр при помощи конструктора по умолчанию (без параметров). 
И только если такого конструктора нет, произойдёт ошибка и тест не сработает.

Поведение spy-объектов по умолчанию идентично поведению обычного экземпляра класса, однако предоставляют те же возможности, что и mock-объекты: 
  позволяют переопределять их поведение и наблюдать за их использованием (см. следующие разделы). 
Важный момент: spy — не обёртка вокруг того экземпляра, на основе которого он создан! Поэтому вызов метода spy на состояние изначального экземпляра не повлияет.

---
Управление поведением

В целом управление поведением mock-объекта сводится к одной очевидной концепции: когда на mock так-то воздействовали (то есть вызван такой-то метод с такими-то аргументами), он должен отреагировать так-то и так-то. У этой концепции существуют две реализации в рамках класса Mockito — основная, рекомендуемая разработчиками к использованию везде, где это возможно, и альтернативная, применяемая там, где основная не годится.

Основная реализация базируется на методе Mockito.when. Этот метод принимает в качестве "параметра" вызов переопределяемого метода mock-объекта (таким образом фиксируется определяемое воздействие) и возвращает объект типа OngoingStubbing, позволяющий вызвать один из методов семейства .then... (так задаётся реакция на это воздействие). Всё вместе в простейшем случае выглядит примерно так:

List<String> data = new ArrayList<>();
data.add("dataItem");
Mockito.when(dataService.getAllData()).thenReturn(data);

После этой операции, вызвав у объекта dataService метод getAllData(), получим объект, заданный в первой строчке листинга.

С точки зрения синтаксиса Java значением, передаваемым методу when в качестве параметра, является, разумеется, значение, возвращаемое переопределяемым методом. Для mock это пустое значение, для spy — значение, возвращаемое методом реального объекта. Но благодаря действующей "под капотом" Mockito магии метод when сработает штатным образом (а не упадёт при запуске с ошибкой) лишь в том случае, если внутри скобок после when находится именно вызов метода mock-объекта.

Альтернативная реализация связывания условия и результата вызова — методы семейства Mockito.do.... Эти методы позволяют задать поведение начиная с результата вызова и возвращают объект класса Stubber, уже при помощи которого можно задать условие. То же самое связывание, что и выше, выполненное этим способом, выглядит так:
List<String> data = new ArrayList<>();
data.add("dataItem");
Mockito.doReturn(data).when(dataService).getData()

Обратите внимание: в первой реализации при задании поведения метода (в данном случае getAllData()) сначала выполняется вызов ещё не переопределённой его версии, и только потом, в недрах Mockito, происходит переопределение. Во второй же такого вызова не происходит — методу Stubber.when передаётся непосредственно mock, а уже у возвращённого этим методом объекта того же типа, но другой природы совершается вызов переопределяемого метода. Эта разница всё и определяет.

Связывание через Mockito.do... никак не контролирует на стадии компиляции то, какой переопределяемый метод вызовем и совместим ли он по типу с заданным возвращаемым значением.

Поэтому обычно Mockito.when предпочтительнее — там с этим ошибки быть не может. Зато возможны случаи, когда хотим избежать вызова непереопределённого метода — для свежесозданного mock такой вызов вполне приемлем, но если ранее уже переопределили этот метод или имеем дело со spy, он может оказаться нежелательным, а при выбрасывании исключения и вовсе не позволит выполнить нужное переопределение. И вот тут помогает связывание через Mockito.do....

Ещё одна ситуация, где не обойтись без методов Mockito.do..., — переопределение метода, возвращающего void: ожидающий параметра Mockito.when с таким методом работать не может. 
Mockito.doReturn тут не поможет, зато есть Mockito.doThrow, Mockito.doAnswer и достаточно редко пригождающийся Mockito.doNothing.

---
Задание условий вызова
...





-------
https://testengineer.ru/testng-tutorial/
https://habr.com/ru/articles/444982/
https://habr.com/ru/articles/590741/

https://blog.skillfactory.ru/glossary/mockito/

when().thenThrow() и when().thenReturn() проверить

